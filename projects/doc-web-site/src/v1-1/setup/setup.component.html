<mat-card>
  <mat-card-title>
    Welcome to NgTranslation!
  </mat-card-title>

  <mat-card-content>
    <p>
      NgTranslation is a localization support package for Angular 6 applications.
    </p>
  </mat-card-content>
</mat-card>

<mat-card>
  <mat-card-title>
    Installation
  </mat-card-title>

  <mat-card-content>
    <p>
      First you need to install the npm module:
    </p>
    <pre>npm install @logikum/ng-translation --save</pre>
  </mat-card-content>
</mat-card>

<mat-card>
  <mat-card-title>
    Setup
  </mat-card-title>

  <mat-card-content>
    <h3>Root module</h3>
    <p>
      To use ng-translation you have to import the NgTranslationModule.forRoot()
      in the root module of your Angular application:
    </p>
<pre>import &#123; BrowserModule } from '@angular/platform-browser';
import &#123; NgModule } from '@angular/core';
<strong>import &#123; NgTranslationModule } from '@logikum/ng-translation';</strong>

@NgModule(&#123;
  imports: [
    BrowserModule,
    <strong>NgTranslationModule.forRoot( <em>configuration</em> )</strong>
  ],
  bootstrap: [
    AppComponent
  ]
})
export class AppModule &#123; }</pre>
    <p>
      The forRoot method requires a configuration object, see later.
    </p>
    <h3>Feature modules or shared module</h3>
    <p>
      In feature modules you have to use the NgTranslationModule.forChild()
      method, or if you use a shared module that you import in multiple other
      feature modules, you can export the NgTranslationModule to make sure you
      don't have to import it in every module.
    </p>
<pre>@NgModule(&#123;
  exports: [
    CommonModule,
    <strong>NgTranslationModule.forChild()</strong>
  ]
})
export class SharedModule &#123; }</pre>
    <h3>Lazy loaded modules</h3>
    <p>
      For lazy loaded modules yuo have to use the LoadTranslationsGuard in the
      route definitions to load the translations before loading the modules:
    </p>
<pre>import &#123; RouterModule, Routes } from '@angular/router';
<strong>import &#123; NgTranslationModule, LoadTranslationsGuard } from '@logikum/ng-translation';</strong>

const routes: Routes = [
  &#123; path: '', redirectTo: 'home', pathMatch: 'full' },
  &#123; path: 'home', component: SetupComponent },
  &#123;
    path: 'lazy',
    loadChildren: './lazy/lazy.module#LazyModule',
    <strong>canLoad: [ LoadTranslationsGuard ]</strong>
  },
  &#123; path: '**', redirectTo: 'home' }
];

@NgModule(&#123;
  imports: [
    BrowserModule,
    RouterModule.forRoot( routes ),
    <strong>NgTranslationModule.forRoot( <em>configuration</em> )</strong>
  ]
})
export class AppModule &#123; }</pre>
    <p>
      The translations belonging to the lazy loaded modules are identified by the
      path. To avoid path conflicts you can use an alternative way to identify the
      proper translation. Add a data object having a section prefix property to
      the route definition:
    </p>
<pre>const routes: Routes = [
  &#123; path: '', redirectTo: 'home', pathMatch: 'full' },
  &#123; path: 'home', component: SetupComponent },
  &#123;
    path: 'lazy',
    loadChildren: './lazy/lazy.module#LazyModule',
    <strong>canLoad: [ LoadTranslationsGuard ],
    data: &#123; sectionPrefix: 'laggard' }</strong>
  },
  &#123; path: '**', redirectTo: 'home' }
];</pre>
  </mat-card-content>

  <mat-card-actions>
    <span class="fill-remaining-space"></span>

    <span class="control-text">Configuration</span>
    <a href="configuration">
      <button mat-fab color="accent">
        <i class="fas fa-chevron-right control-button"></i>
      </button>
    </a>
  </mat-card-actions>
</mat-card>
